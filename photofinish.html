<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Finish Pro</title>
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>

    <style>
        /* Define CSS Variables for theming */
        :root {
            --bg-color: #f0f0f0;
            --text-color: #333;
            --container-bg: #f9f9f9;
            --container-border: #ccc;
            --input-bg: white;
            --input-border: #ccc;
            --input-text: #333;
            --button-primary-bg: #007bff;
            --button-primary-hover-bg: #0056b3;
            --button-secondary-bg: #4CAF50; /* Start button */
            --button-secondary-hover-bg: #45a049;
            --button-danger-bg: #f44336; /* Reset button */
            --button-danger-hover-bg: #da190b;
            --button-warning-bg: #ff9800; /* Toggle Detection */
            --button-warning-hover-bg: #f57c00;
            --button-info-bg: #607d8b; /* Email & Theme & Sheet button */
            --button-info-hover-bg: #546e7a;
            --button-text-color: white;
            --disabled-bg-color: #cccccc;
            --disabled-text-color: #666666;
            --link-color: #007bff;
            --placeholder-text-color: white;
            --status-text-color: #333;
            --finish-line-color: rgba(255, 0, 0, 0.7);
            --camera-container-bg: #333;
            --result-entry-bg: white;
            --result-entry-border: #ddd;
        }

        body.dark-mode {
            --bg-color: #1e1e1e;
            --text-color: #e0e0e0;
            --container-bg: #2c2c2c;
            --container-border: #444;
            --input-bg: #3a3a3a;
            --input-border: #555;
            --input-text: #e0e0e0;
            --button-primary-bg: #0056b3;
            --button-primary-hover-bg: #004085;
            --button-secondary-bg: #388e3c;
            --button-secondary-hover-bg: #2e7d32;
            --button-danger-bg: #c62828;
            --button-danger-hover-bg: #b71c1c;
            --button-warning-bg: #ef6c00;
            --button-warning-hover-bg: #e65100;
            --button-info-bg: #455a64;
            --button-info-hover-bg: #37474f;
            --button-text-color: #e0e0e0;
            --disabled-bg-color: #424242;
            --disabled-text-color: #888888;
            --link-color: #4dabf7;
            --placeholder-text-color: #ccc;
            --status-text-color: #e0e0e0;
            --camera-container-bg: #111;
            --result-entry-bg: #2c2c2c;
            --result-entry-border: #444;
        }

        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        h1, h2, h3, h4 {
            color: var(--text-color);
        }
        #cameraContainer {
            position: relative;
            width: 90vw;
            max-width: 640px;
            height: calc(90vw * 0.75);
            max-height: 480px;
            border: 2px solid var(--text-color);
            margin-bottom: 10px;
            background-color: var(--camera-container-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--placeholder-text-color);
            text-align: center;
            overflow: hidden;
            cursor: default;
        }
        #cameraFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #finishLineOverlay {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 5px;
            background-color: var(--finish-line-color);
            transform: translateX(-50%);
            cursor: ew-resize;
            display: none;
            z-index: 10;
        }
        #controls, #settingsArea, #resultsArea {
            margin-bottom: 20px;
            text-align: center;
            width: 90%;
            max-width: 640px;
        }
        #controls button, #setupCameraButton, #settingsArea button, #resultsArea button {
            padding: 10px 15px;
            font-size: 1em;
            margin: 5px;
            cursor: pointer;
            color: var(--button-text-color);
            border: none;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        #setupCameraButton { background-color: var(--button-primary-bg); }
        #setupCameraButton:hover { background-color: var(--button-primary-hover-bg); }
        #startButton { background-color: var(--button-secondary-bg); }
        #startButton:hover { background-color: var(--button-secondary-hover-bg); }
        #startButton:disabled, #resetButton:disabled, #emailResultsButton:disabled, #sendToSheetButton:disabled {
            background-color: var(--disabled-bg-color);
            color: var(--disabled-text-color);
            cursor: not-allowed;
        }
        #resetButton { background-color: var(--button-danger-bg); }
        #resetButton:hover { background-color: var(--button-danger-hover-bg); }
        #toggleDetectionModeButton { background-color: var(--button-warning-bg); }
        #toggleDetectionModeButton:hover { background-color: var(--button-warning-hover-bg); }

        #emailResultsButton, #themeToggleButton, #sendToSheetButton { /* Grouped common styling */
             background-color: var(--button-info-bg);
             padding: 10px 15px;
             font-size: 1em;
             margin: 5px;
             cursor: pointer;
             color: var(--button-text-color);
             border: none;
             border-radius: 5px;
             transition: background-color 0.2s;
        }
        #emailResultsButton:hover, #themeToggleButton:hover, #sendToSheetButton:hover {
            background-color: var(--button-info-hover-bg);
        }

        #settingsArea {
            border: 1px solid var(--container-border);
            padding: 15px;
            margin-top: 10px;
            background-color: var(--container-bg);
            border-radius: 5px;
        }
        .setting-item {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .setting-item label {
            margin-right: 10px;
            flex-basis: 60%;
            text-align: left;
            color: var(--text-color);
        }
        .setting-item input[type="number"], .setting-item input[type="text"], .setting-item input[type="email"] {
            flex-basis: 35%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid var(--input-border);
            background-color: var(--input-bg);
            color: var(--input-text);
            border-radius: 3px;
        }
        #runnerNamesAreaContainer h4 {
            margin-top: 15px;
            margin-bottom: 5px;
            text-align: left;
            font-size: 0.95em;
            color: var(--text-color);
        }

        #resultsArea h2 { margin-bottom: 10px; }
        .result-entry {
            border: 1px solid var(--result-entry-border);
            padding: 10px;
            margin-bottom: 10px;
            background-color: var(--result-entry-bg);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .result-entry span { margin-right: 10px; color: var(--text-color); }
        .result-entry a {
            margin-left: auto;
            display: inline-block;
            color: var(--link-color);
        }
        .result-entry img {
            width: 120px;
            height: 90px;
            object-fit: cover;
            border: 1px solid var(--result-entry-border);
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
            vertical-align: middle;
        }
        .result-entry img:hover {
            transform: scale(1.1);
        }
        #status {
            font-weight: bold;
            color: var(--status-text-color);
            margin-top: 10px;
            min-height: 20px;
            font-size: 0.9em;
        }
        #frameCanvas { display: none; }
        /* #emailNotice removed */
        #settingsArea small {
            color: var(--text-color);
            display: block;
            text-align: left;
            margin-top: 5px;
            font-size: 0.85em;
        }
    </style>
</head>
<body class="dark-mode">
    <!-- MODIFIED: justify-content changed to center for the h1 -->
    <div style="display: flex; justify-content: center; align-items: center; width: 90%; max-width: 640px;">
        <h1>DLS PhotoFinish Pro</h1>
    </div>

    <div id="cameraContainer">
        <video id="cameraFeed" autoplay playsinline muted></video>
        <div id="cameraPlaceholderText" style="display: block;">Click "Setup Camera" below to begin.</div>
        <div id="finishLineOverlay"></div>
    </div>
    <canvas id="frameCanvas"></canvas>

    <button id="setupCameraButton">Setup Camera</button>

    <!-- MOVED: Controls div (Start/Reset buttons) moved above settingsArea -->
    <div id="controls">
        <button id="startButton" disabled>Start Race</button>
        <button id="resetButton" disabled>Reset</button>
    </div>

    <div id="settingsArea" style="display:none;">
        <h3>Settings</h3>
        <div class="setting-item">
            <label for="numRacersInput">Number of Racers:</label>
            <input type="number" id="numRacersInput" value="2" min="1" max="20">
        </div>
        <div id="runnerNamesAreaContainer"></div>
        <hr style="margin: 15px 0;">
        <div class="setting-item">
            <label>Detection Mode: <strong id="currentDetectionMode">Object Detection</strong></label>
            <button id="toggleDetectionModeButton">Switch to Pixel Difference</button>
        </div>
        <div id="pixelDiffSettings" style="display:none;">
            <div class="setting-item">
                <label for="detectionThresholdInput">Pixel Diff. Sensitivity Threshold:</label>
                <input type="number" id="detectionThresholdInput" value="200000" min="10000" step="10000">
            </div>
            <div class="setting-item">
                <label for="roiWidthInput">Pixel Diff. ROI Width (px):</label>
                <input type="number" id="roiWidthInput" value="5" min="1" max="50">
            </div>
        </div>
        <div id="objectDetectionSettings" style="display:block;">
            <div class="setting-item">
                <label for="minConfidenceInput">Object Detection Min. Confidence:</label>
                <input type="number" id="minConfidenceInput" value="0.5" min="0.1" max="0.99" step="0.05">
            </div>
             <small>Object detection uses the COCO-SSD model to find "person" objects.</small>
        </div>
    </div>

    <div id="status">Status: Awaiting camera setup.</div>

    <div id="resultsArea">
        <h2>Results</h2>
        <div id="resultsLog"></div>
        <div class="setting-item" style="margin-top: 15px; margin-bottom: 5px; justify-content: center;">
            <label for="recipientEmailInput" style="flex-basis: auto; margin-right: 5px;">Email to:</label>
            <input type="email" id="recipientEmailInput" value="photofinish@deerlakeschool.ca" style="flex-basis: 250px; padding: 8px;">
        </div>
        <button id="emailResultsButton" disabled>Email Results (Text Only)</button>
        <button id="themeToggleButton">Switch to Light Mode</button>
        <button id="sendToSheetButton" disabled>Send Race to Sheet</button>
        <!-- REMOVED: <div id="emailNotice">...</div> -->
    </div>

    <script>
        const video = document.getElementById('cameraFeed');
        const canvas = document.getElementById('frameCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const setupCameraButton = document.getElementById('setupCameraButton');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const resultsLog = document.getElementById('resultsLog');
        const statusDiv = document.getElementById('status');
        const finishLineOverlay = document.getElementById('finishLineOverlay');
        const cameraPlaceholderText = document.getElementById('cameraPlaceholderText');
        const cameraContainer = document.getElementById('cameraContainer');
        const themeToggleButton = document.getElementById('themeToggleButton');
        const sendToSheetButton = document.getElementById('sendToSheetButton');

        const settingsAreaDiv = document.getElementById('settingsArea');
        const numRacersInput = document.getElementById('numRacersInput');
        const runnerNamesAreaContainer = document.getElementById('runnerNamesAreaContainer');
        const detectionThresholdInput = document.getElementById('detectionThresholdInput');
        const roiWidthInput = document.getElementById('roiWidthInput');
        const minConfidenceInput = document.getElementById('minConfidenceInput');
        const toggleDetectionModeButton = document.getElementById('toggleDetectionModeButton');
        const currentDetectionModeDisplay = document.getElementById('currentDetectionMode');
        const pixelDiffSettingsDiv = document.getElementById('pixelDiffSettings');
        const objectDetectionSettingsDiv = document.getElementById('objectDetectionSettings');
        const emailResultsButton = document.getElementById('emailResultsButton');
        const recipientEmailInput = document.getElementById('recipientEmailInput');

        // --- PASTE YOUR GOOGLE APPS SCRIPT WEB APP URL HERE ---
        // --- This URL MUST be from a DEPLOYED web app, with permissions set to "Anyone" ---
        const GOOGLE_SHEET_WEB_APP_URL = "https://script.google.com/macros/s/AKfycbynqZa0-SvprfOkAvL5nnGQeWU7sDBzgfH0SXVWm-kWQ6vJVejoWWR4K6v0aGbBIaWq/exec"; // <<-- URL UPDATED HERE


        let stream;
        let raceTimerActive = false;
        let raceStartTime = 0;
        let previousFramePixelData = null;
        let runnerCount = 0;
        let MAX_RUNNERS = parseInt(numRacersInput.value);
        let raceConfiguredMaxRunners = MAX_RUNNERS;
        let runnerNames = [];
        let animationFrameId;
        let currentRaceId = null;
        let raceResultsForSheet = [];

        let DETECTION_THRESHOLD = parseInt(detectionThresholdInput.value);
        let ROI_WIDTH_PIXELS = parseInt(roiWidthInput.value);
        let MIN_CONFIDENCE = parseFloat(minConfidenceInput.value);
        const COOLDOWN_FRAMES = 30;
        let framesSinceLastDetection = 0;
        let finishLinePercentX = 50;
        let isDraggingLine = false;
        let detectionMode = 'object';
        let objectDetectionModel = null;
        let modelReady = false;

        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                themeToggleButton.textContent = 'Switch to Light Mode';
            } else {
                document.body.classList.remove('dark-mode');
                themeToggleButton.textContent = 'Switch to Dark Mode';
            }
        }

        themeToggleButton.onclick = () => {
            let newTheme = 'dark';
            if (document.body.classList.contains('dark-mode')) newTheme = 'light';
            applyTheme(newTheme);
            try { localStorage.setItem('photoFinishTheme', newTheme); } catch(e) { console.warn("LocalStorage not available for theme saving."); }
        };

        let initialTheme = 'dark';
        try {
            const savedTheme = localStorage.getItem('photoFinishTheme');
            if (savedTheme) initialTheme = savedTheme;
        } catch(e) { console.warn("LocalStorage not available for theme loading."); }
        applyTheme(initialTheme);

        function updateRunnerNameInputs() {
            const numRacers = parseInt(numRacersInput.value);
            runnerNamesAreaContainer.innerHTML = '';
            if (isNaN(numRacers) || numRacers < 1 || numRacers > parseInt(numRacersInput.max)) {
                runnerNames = []; return;
            }
            const oldRunnerNames = [...runnerNames];
            runnerNames = new Array(numRacers);
            const heading = document.createElement('h4');
            heading.textContent = 'Runner Names (Optional):';
            runnerNamesAreaContainer.appendChild(heading);
            for (let i = 0; i < numRacers; i++) {
                runnerNames[i] = oldRunnerNames[i] || '';
                const itemDiv = document.createElement('div'); itemDiv.className = 'setting-item';
                const label = document.createElement('label'); label.htmlFor = `runnerNameInput${i}`; label.textContent = `Racer ${i + 1} Name:`;
                const input = document.createElement('input'); input.type = 'text'; input.id = `runnerNameInput${i}`;
                input.placeholder = `Name for Racer ${i + 1}`; input.value = runnerNames[i]; input.dataset.index = i;
                input.oninput = (event) => { runnerNames[parseInt(event.target.dataset.index)] = event.target.value.trim(); };
                itemDiv.appendChild(label); itemDiv.appendChild(input); runnerNamesAreaContainer.appendChild(itemDiv);
            }
        }

        numRacersInput.onchange = () => {
            const newMax = parseInt(numRacersInput.value);
            if (isNaN(newMax) || newMax < 1 || newMax > parseInt(numRacersInput.max)) {
                numRacersInput.value = MAX_RUNNERS; return;
            }
            MAX_RUNNERS = newMax; updateRunnerNameInputs();
        };
        detectionThresholdInput.onchange = () => DETECTION_THRESHOLD = parseInt(detectionThresholdInput.value);
        roiWidthInput.onchange = () => ROI_WIDTH_PIXELS = parseInt(roiWidthInput.value);
        minConfidenceInput.onchange = () => MIN_CONFIDENCE = parseFloat(minConfidenceInput.value);

        toggleDetectionModeButton.onclick = () => {
            if (detectionMode === 'pixel') {
                detectionMode = 'object'; currentDetectionModeDisplay.textContent = 'Object Detection';
                toggleDetectionModeButton.textContent = 'Switch to Pixel Difference';
                pixelDiffSettingsDiv.style.display = 'none'; objectDetectionSettingsDiv.style.display = 'block';
                if (!modelReady) loadObjectDetectionModel(); else statusDiv.textContent = "Status: Object Detection model ready.";
                startButton.disabled = !modelReady || !(stream && video.srcObject && !video.paused && !video.ended);
            } else {
                detectionMode = 'pixel'; currentDetectionModeDisplay.textContent = 'Pixel Difference';
                toggleDetectionModeButton.textContent = 'Switch to Object Detection';
                pixelDiffSettingsDiv.style.display = 'block'; objectDetectionSettingsDiv.style.display = 'none';
                statusDiv.textContent = "Status: Switched to Pixel Difference mode.";
                startButton.disabled = !(stream && video.srcObject && !video.paused && !video.ended);
            }
            previousFramePixelData = null;
        };

        async function loadObjectDetectionModel() {
            if (modelReady) return;
            statusDiv.textContent = "Status: Loading Object Detection model..."; startButton.disabled = true;
            try {
                objectDetectionModel = await cocoSsd.load(); modelReady = true;
                statusDiv.textContent = "Status: Object Detection model loaded. Ready.";
                if (stream && video.srcObject && !video.paused && !video.ended) startButton.disabled = false;
            } catch (err) {
                console.error("Error loading COCO-SSD model:", err);
                statusDiv.textContent = "Error: Could not load OD model. Switching to Pixel Difference.";
                detectionMode = 'pixel'; currentDetectionModeDisplay.textContent = 'Pixel Difference';
                toggleDetectionModeButton.textContent = 'Switch to Object Detection';
                pixelDiffSettingsDiv.style.display = 'block'; objectDetectionSettingsDiv.style.display = 'none';
                if (stream && video.srcObject && !video.paused && !video.ended) startButton.disabled = false;
            }
        }

        setupCameraButton.onclick = async () => {
            statusDiv.textContent = "Status: Requesting camera access...";
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 640 }, height: { ideal: 480 } } });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                    statusDiv.textContent = "Status: Camera Ready. Drag red line to position finish. Adjust settings if needed.";
                    if (detectionMode === 'object' && !modelReady) {
                        statusDiv.textContent += " Loading OD model..."; startButton.disabled = true; loadObjectDetectionModel();
                    } else if (detectionMode === 'pixel' || (detectionMode === 'object' && modelReady)) {
                        startButton.disabled = false;
                    }
                    setupCameraButton.disabled = true; setupCameraButton.style.display = 'none';
                    // Make sure controls are visible if camera setup is complete
                    document.getElementById('controls').style.display = 'block'; // Or 'inline-block'/'flex' depending on styling
                    settingsAreaDiv.style.display = 'block'; 
                    updateRunnerNameInputs();
                    finishLineOverlay.style.display = 'block'; cameraPlaceholderText.style.display = 'none';
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    processFrameLoop();
                };
                video.onplay = () => { cameraPlaceholderText.style.display = 'none'; }
            } catch (err) {
                console.error("Error accessing camera:", err);
                statusDiv.textContent = `Error: Could not access camera. ${err.name}. Grant permission & try again.`;
                startButton.disabled = true; resetButton.disabled = true; setupCameraButton.disabled = false;
            }
        };

        finishLineOverlay.onmousedown = (e) => { isDraggingLine = true; cameraContainer.style.cursor = 'ew-resize'; e.preventDefault(); };
        document.onmousemove = (e) => {
            if (!isDraggingLine || !stream) return;
            const rect = cameraContainer.getBoundingClientRect(); let x = e.clientX - rect.left;
            x = Math.max(0, Math.min(x, rect.width)); finishLinePercentX = (x / rect.width) * 100;
            finishLineOverlay.style.left = `${finishLinePercentX}%`;
        };
        document.onmouseup = () => { if (isDraggingLine) { isDraggingLine = false; cameraContainer.style.cursor = 'default'; } };

        async function processFrameLoop() {
            if (!stream || !video.srcObject || video.paused || video.ended || !video.videoWidth) {
                animationFrameId = requestAnimationFrame(processFrameLoop); return;
            }
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            if (raceTimerActive && runnerCount < MAX_RUNNERS) {
                const currentElapsedTime = (performance.now() - raceStartTime) / 1000;
                statusDiv.textContent = `Status: Race Running (${runnerCount}/${MAX_RUNNERS})... ${currentElapsedTime.toFixed(3)}s. Mode: ${detectionMode}`;
                framesSinceLastDetection++;
                if (framesSinceLastDetection > COOLDOWN_FRAMES) {
                    let detected = false; const finishLinePixelX = (finishLinePercentX / 100) * canvas.width;
                    if (detectionMode === 'pixel') {
                        const roiX = Math.floor(finishLinePixelX) - Math.floor(ROI_WIDTH_PIXELS / 2);
                        if (roiX >= 0 && roiX + ROI_WIDTH_PIXELS <= canvas.width) {
                            const currentFrameRegion = ctx.getImageData(roiX, 0, ROI_WIDTH_PIXELS, canvas.height);
                            const currentFramePixelData = currentFrameRegion.data;
                            if (previousFramePixelData) {
                                let diffSum = 0;
                                for (let i = 0; i < currentFramePixelData.length; i += 4) {
                                    diffSum += Math.abs(currentFramePixelData[i] - previousFramePixelData[i]);
                                    diffSum += Math.abs(currentFramePixelData[i+1] - previousFramePixelData[i+1]);
                                    diffSum += Math.abs(currentFramePixelData[i+2] - previousFramePixelData[i+2]);
                                }
                                if (diffSum > DETECTION_THRESHOLD) detected = true;
                            }
                            previousFramePixelData = new Uint8ClampedArray(currentFramePixelData);
                        } else console.warn("Pixel ROI out of bounds");
                    } else if (detectionMode === 'object' && modelReady && objectDetectionModel) {
                        const predictions = await objectDetectionModel.detect(canvas);
                        for (const p of predictions) {
                            if (p.class === 'person' && p.score >= MIN_CONFIDENCE) {
                                const objectCenterX = p.bbox[0] + p.bbox[2] / 2;
                                const tolerance = p.bbox[2] / 3; // Detection if center of person is within 1/3 of their width from finish line
                                if (Math.abs(objectCenterX - finishLinePixelX) < tolerance) { detected = true; break; }
                            }
                        }
                    }
                    if (detected) {
                        const elapsedTimeAtDetection = (performance.now() - raceStartTime) / 1000;
                        runnerCount++;
                        const snapshotDataURL = canvas.toDataURL('image/jpeg', 0.8);
                        const resultEntry = document.createElement('div'); resultEntry.classList.add('result-entry');
                        const runnerId = runnerCount;
                        const assignedName = runnerNames[runnerId - 1] && runnerNames[runnerId - 1].trim() !== '' ? runnerNames[runnerId - 1] : `Runner ${runnerId}`;
                        const resultTextTime = `${assignedName}: ${elapsedTimeAtDetection.toFixed(3)}s`;

                        const imageLink = document.createElement('a'); imageLink.href = snapshotDataURL; imageLink.target = "_blank"; imageLink.title = `View snapshot for ${assignedName}`;
                        const snapshotImageTag = document.createElement('img'); snapshotImageTag.src = snapshotDataURL; snapshotImageTag.alt = `Snapshot for ${assignedName}`;
                        imageLink.appendChild(snapshotImageTag);
                        resultEntry.innerHTML = `<span>${resultTextTime}</span>`;
                        resultEntry.appendChild(imageLink);
                        resultsLog.appendChild(resultEntry);
                        statusDiv.textContent = `Status: ${assignedName} detected! Time: ${elapsedTimeAtDetection.toFixed(3)}s`;
                        framesSinceLastDetection = 0;

                        raceResultsForSheet.push({
                            timestamp: new Date().toISOString(),
                            raceId: currentRaceId,
                            runnerName: assignedName,
                            time: parseFloat(elapsedTimeAtDetection.toFixed(3))
                        });

                        if (runnerCount >= MAX_RUNNERS) {
                            raceTimerActive = false; statusDiv.textContent = "Status: Race Finished! All runners recorded.";
                            startButton.disabled = true; resetButton.disabled = false; emailResultsButton.disabled = false;
                            if (GOOGLE_SHEET_WEB_APP_URL && GOOGLE_SHEET_WEB_APP_URL !== "YOUR_DEPLOYED_GOOGLE_APPS_SCRIPT_WEB_APP_URL_HERE" && GOOGLE_SHEET_WEB_APP_URL.startsWith("https://")) {
                                sendToSheetButton.disabled = false;
                            } else {
                                console.warn("SendToSheet button NOT enabled at race end because GOOGLE_SHEET_WEB_APP_URL is not correctly configured.");
                            }
                        }
                    }
                }
            } else if (video.srcObject && !video.paused && !video.ended && detectionMode === 'pixel') {
                if (previousFramePixelData) previousFramePixelData = null;
            }
            animationFrameId = requestAnimationFrame(processFrameLoop);
        }

        startButton.onclick = () => {
            MAX_RUNNERS = parseInt(numRacersInput.value);
            if (isNaN(MAX_RUNNERS) || MAX_RUNNERS < 1 || MAX_RUNNERS > parseInt(numRacersInput.max)) {
                alert("Please enter a valid number of racers (1 to " + numRacersInput.max + ").");
                numRacersInput.value = Math.max(1, Math.min(parseInt(numRacersInput.max), MAX_RUNNERS || 1));
                MAX_RUNNERS = parseInt(numRacersInput.value); updateRunnerNameInputs(); return;
            }
            raceConfiguredMaxRunners = MAX_RUNNERS; currentRaceId = "RACE_" + Date.now();
            raceResultsForSheet = [];

            if (runnerCount >= MAX_RUNNERS) { statusDiv.textContent = "Status: Race already finished. Please Reset."; return; }
            if (!stream || !video.srcObject || video.paused || video.ended) { statusDiv.textContent = "Status: Camera not ready."; return; }
            if (detectionMode === 'object' && !modelReady) {
                statusDiv.textContent = "Status: Object Detection model not ready.";
                if (!objectDetectionModel && !modelReady) loadObjectDetectionModel(); return;
            }
            if (runnerNames.length !== MAX_RUNNERS) updateRunnerNameInputs();
            raceTimerActive = true; raceStartTime = performance.now(); previousFramePixelData = null;
            framesSinceLastDetection = COOLDOWN_FRAMES + 1; startButton.disabled = true; resetButton.disabled = false;
            emailResultsButton.disabled = true; sendToSheetButton.disabled = true;
            settingsAreaDiv.style.display = 'none';
            statusDiv.textContent = `Status: Race Started! Waiting for ${MAX_RUNNERS} runner(s). Timer Running... 0.000s`;
        };

        resetButton.onclick = () => {
            raceTimerActive = false; runnerCount = 0; resultsLog.innerHTML = ''; previousFramePixelData = null;
            currentRaceId = null; raceResultsForSheet = [];
            let canStart = (stream && video.srcObject && !video.paused && !video.ended);
            if (detectionMode === 'object' && !modelReady) canStart = false;
            startButton.disabled = !canStart; resetButton.disabled = true; emailResultsButton.disabled = true; sendToSheetButton.disabled = true;
            if (stream && video.srcObject) {
                // Ensure controls and settings are visible and appropriately styled after reset if camera is active
                document.getElementById('controls').style.display = 'block'; // Or 'inline-block'/'flex' etc.
                settingsAreaDiv.style.display = 'block';
                updateRunnerNameInputs();
                statusDiv.textContent = "Status: Ready for new race. Position finish line.";
            } else {
                settingsAreaDiv.style.display = 'none'; runnerNamesAreaContainer.innerHTML = '';
                document.getElementById('controls').style.display = 'block'; // Or 'none' if no camera
                setupCameraButton.disabled = false; setupCameraButton.style.display = 'inline-block';
                finishLineOverlay.style.display = 'none'; cameraPlaceholderText.style.display = 'block';
                startButton.disabled = true; statusDiv.textContent = "Status: Camera disconnected.";
            }
        };

        emailResultsButton.onclick = () => {
            const currentRecipientEmail = recipientEmailInput.value.trim();
            if (!currentRecipientEmail) { alert("Please enter a recipient email address."); recipientEmailInput.focus(); return; }
            const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; if (!emailPattern.test(currentRecipientEmail)) { alert("Please enter a valid email address."); recipientEmailInput.focus(); return; }
            const resultsTextArray = []; resultsLog.querySelectorAll('.result-entry span').forEach(s => resultsTextArray.push(s.textContent));
            if (resultsTextArray.length === 0) { alert("No results to email."); return; }
            const subject = "Photo Finish Race Results";
            // MODIFIED: Removed the server-side setup note from the email body
            const body = "Race Results:\n\n" + resultsTextArray.join("\n") + `\n\nTotal Runners Configured for this Race: ${raceConfiguredMaxRunners}`;
            const mailtoLink = `mailto:${encodeURIComponent(currentRecipientEmail)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            window.location.href = mailtoLink;
        };

        async function sendAllResultsToGoogleSheet(resultsArray) {
            const webAppURL = GOOGLE_SHEET_WEB_APP_URL;
            console.log("Attempting to send data to Google Sheet URL:", webAppURL);

            if (!webAppURL || webAppURL === "YOUR_DEPLOYED_GOOGLE_APPS_SCRIPT_WEB_APP_URL_HERE" || !webAppURL.startsWith("https://")) {
                alert("Google Sheet Web App URL is not configured correctly. Please update it in the HTML script.");
                console.warn("Google Sheet Web App URL is not configured. Data not sent.");
                return false;
            }
            if (!resultsArray || resultsArray.length === 0) {
                alert("No results to send to sheet.");
                return false;
            }

            const payload = { results: resultsArray };
            const originalStatus = statusDiv.textContent;
            statusDiv.textContent += " (Sending to Sheet...)";
            sendToSheetButton.disabled = true;

            try {
                const response = await fetch(webAppURL, {
                    method: 'POST',
                    mode: 'cors',
                    cache: 'no-cache',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const responseText = await response.text();
                let responseData;
                try {
                    responseData = JSON.parse(responseText);
                } catch (e) {
                    console.error("Failed to parse JSON response from Apps Script:", responseText);
                    // This is crucial for debugging if the Apps Script returns non-JSON (e.g., HTML error page)
                    responseData = { status: "error", message: "Invalid JSON response from server. Raw response (first 100 chars): " + responseText.substring(0, 100) };
                }

                if (response.ok && responseData && responseData.status === "success") {
                    console.log("Batch data successfully sent to Google Sheet:", responseData);
                    statusDiv.textContent = originalStatus + ` (Sent ${responseData.processedCount || resultsArray.length} results to Sheet!)`;
                    return true;
                } else {
                    // Log the full response text if it wasn't a JSON success for better debugging
                    if (!(responseData && responseData.status === "success")){
                        console.error("Full response text from Apps Script:", responseText);
                    }
                    const errorMsg = `Error sending batch data. Server Status: ${response.status}. Message: ${responseData.message || "Unknown error from Apps Script. Check console for details."}`;
                    console.error(errorMsg);
                    statusDiv.textContent = originalStatus + " (Sheet batch send error!)";
                    alert(errorMsg);
                    return false;
                }
            } catch (error) { // Network error or other fetch-related issue
                console.error("Fetch error sending batch data to Google Sheet:", error);
                statusDiv.textContent = originalStatus + " (Sheet batch send error! Check console.)";
                alert("Fetch error: " + error.message + ". Ensure the Apps Script URL is correct, deployed with 'Anyone' access, and your network allows the connection. Check browser console (Network tab) for details.");
                return false;
            } finally {
                setTimeout(() => {
                    if (statusDiv.textContent.includes("(Sending to Sheet...)") || statusDiv.textContent.includes("(Sheet batch send error!)") || statusDiv.textContent.includes("results to Sheet!)")) {
                       statusDiv.textContent = originalStatus;
                    }
                    if (resultsArray.length > 0 ) {
                       sendToSheetButton.disabled = false; // Always re-enable to allow retry
                    }
                }, 5000);
            }
        }

        sendToSheetButton.onclick = async () => {
            if (raceResultsForSheet.length === 0) {
                alert("No results recorded for this race to send.");
                return;
            }
            const success = await sendAllResultsToGoogleSheet(raceResultsForSheet);
            if (success) {
                alert(raceResultsForSheet.length + " results sent to Google Sheet successfully!");
            }
        };

        // Initial state setup
        document.getElementById('controls').style.display = 'block'; // Make sure controls are visible initially
        startButton.disabled = true; resetButton.disabled = true; emailResultsButton.disabled = true; sendToSheetButton.disabled = true;
        if (!GOOGLE_SHEET_WEB_APP_URL || GOOGLE_SHEET_WEB_APP_URL === "YOUR_DEPLOYED_GOOGLE_APPS_SCRIPT_WEB_APP_URL_HERE" || !GOOGLE_SHEET_WEB_APP_URL.startsWith("https://")) {
            console.warn("Google Sheet Web App URL not configured or is a placeholder. 'Send to Sheet' button will be non-functional until configured and a race is completed. Please update the GOOGLE_SHEET_WEB_APP_URL constant in the script section of this HTML file.");
        }


        if (detectionMode === 'object') { /* UI already set by HTML default */ }
        else {
            currentDetectionModeDisplay.textContent = 'Pixel Difference'; toggleDetectionModeButton.textContent = 'Switch to Object Detection';
            pixelDiffSettingsDiv.style.display = 'block'; objectDetectionSettingsDiv.style.display = 'none';
        }

        window.addEventListener('beforeunload', (event) => {
            if (raceTimerActive || resultsLog.children.length > 0) {
                event.preventDefault();
                event.returnValue = '';
            }
            if (stream) stream.getTracks().forEach(track => track.stop());
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
        });
    </script>
</body>
</html>
